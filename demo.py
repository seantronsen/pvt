##################################################
# FILE: demo.py
# AUTHOR: SEAN TRONSEN
#
# SUMMARY:
# The contents of this file are written with the intent to illustrate basic
# usage of the package utilities. Users should not expect it to be
# comprehensive.
#
# Should the reader have any questions, they are advised to first skim through
# the source code and read the inline documentation. For any questions that
# still remain, please get in touch with the author or submit a github issue.
##################################################
##################################################

# NOTE: Performance logging can be enabled with this environment variable.
# IMPORTANT: It must be set via the command line or prior to importing the
# library
import os

os.environ["VIEWER_DEBUG"] = "1"  # remove to disable performance logging

from pvt.app import App
from pvt.context import VisualizerContext
from pvt.controls import StatefulAnimator, StatefulTrackbar
from pvt.displays import (
    ImageViewConfig,
    PlotDataLine,
    PlotDataScatter,
    PlotView2DConfig,
    StatefulImageView,
    StatefulPlotView2D,
)
from pvt.qtmods import TrackbarConfig


# STANDARD IMPORTS
import cv2
import numpy as np
import sys
from pvt.utils import norm_uint8, resize_by_ratio

# IMPORTANT: Visualizer Context & Callback Parameter Handling:
#
# The visualizer context is a grouping mechanism that links control widgets
# and data display widgets. Only controls and displays within the same
# context communicate, ensuring that state updates and data refreshes don't
# interfere across unrelated explorations.
#
# Callback Parameter Handling:
#
#   - Callbacks receive parameters as keyword arguments (key=value pairs) generated by
#     control widgets in the same visualizer context.
#
#   - Control widgets emit state updates where the key of the key=value pair must match the callback's
#     parameter name exactly for proper mapping.
#
#   - Use **kwargs in your callback to ignore extra parameters if your function only
#     needs a subset of the provided variables.
#
#   - Without **kwargs, the callback must explicitly define a parameter for every control
#     widget variable, or Python will raise an exception.
#
# This approach lets you focus on the parameters your callback truly requires while the
# context takes care of the rest.


def demo_image_viewer():
    img_test = cv2.imread("sample-media/checkboard_non_planar.png").astype(np.uint8)
    img_test = norm_uint8(cv2.cvtColor(img_test, cv2.COLOR_BGR2GRAY))

    # IMPORTANT: Expensive and avoidable computations should be completed prior for
    # best results. Slow rendering times can only be attributed to bottlenecks
    # in the callback functions you define. For more details, export
    # `VIEWER_DEBUG=1` to the list of environment variables.
    #
    # EXAMPLE: Compare rendering speed for interactions with the resize vs.
    # sigma sliders (resize performs more computation, making it slower by
    # comparison).
    img_test_small = img_test.copy()
    img_test = resize_by_ratio(img_test, 10)
    noise_image = np.random.randn(*(img_test.shape)).astype(np.int8)  # pyright: ignore

    def callback_0(rho, sigma, **_):
        resized = resize_by_ratio(img_test, rho)
        noise_slice = noise_image[: resized.shape[0], : resized.shape[1]]
        result = resized + (noise_slice * sigma)
        return result

    def callback_1(sigma, **_):
        noise_slice = noise_image[: img_test_small.shape[0], : img_test_small.shape[1]]
        result = img_test_small + (noise_slice * sigma)
        return result

    # define interface and run application
    # happy tuning / visualizing!
    app = App(title="Example for Displaying Rapid Image Updates")

    trackbar_rho = StatefulTrackbar(key="rho", tb_range=TrackbarConfig(start=0.001, stop=1, step=0.001, init=0.5))
    trackbar_sigma = StatefulTrackbar("sigma", TrackbarConfig(0, 100, 2))
    ip_a = StatefulImageView(callback_0, title="resized image")
    ip_b = StatefulImageView(
        callback_1,
        config=ImageViewConfig(border_color="red", autoRange=False),
        title="small image for perf",
    )

    # IMPORTANT: add all display and control elements to a context so they can communicate
    # this helper function also creates a mosaic (grid-like) layout of the widgets
    context = VisualizerContext.create_viewer_from_mosaic([[ip_a, ip_b], [trackbar_rho, trackbar_sigma]])
    app.add_panes(context)
    app.run()


# An example to showcase various plotting features
def demo_plot_viewer():
    N_WAVES = 5

    def _callback_base(nsamples, sigma, omega, phasem, animation_tick, **_):
        cphase = (animation_tick / (2 * np.pi)) * phasem
        sinusoid = np.sin((np.linspace(0, omega * 2 * np.pi, nsamples) + cphase))
        noise = np.random.randn(nsamples)
        result = sinusoid + (noise[:nsamples] * sigma)
        return np.array([result] * N_WAVES) + (np.arange(N_WAVES).reshape(-1, 1) - ((N_WAVES - 1) / 2))

    def callback_line(nsamples, sigma, omega, phasem, animation_tick, **_):
        result = _callback_base(nsamples, sigma, omega, phasem, animation_tick, **_)
        return [PlotDataLine(x=np.arange(signal.size), y=signal, name=f"item: {i}") for i, signal in enumerate(result)]

    def callback_scatter(nsamples, sigma, omega, phasem, animation_tick, **_):
        result = _callback_base(nsamples, sigma, omega, phasem, animation_tick, **_)
        return [PlotDataScatter(x=np.arange(signal.size), y=signal, marker="x") for signal in result]

    app = App(title="Multiple Plots: An Illustration of Signal Aliasing")

    trackbar_n = StatefulTrackbar("nsamples", tb_range=TrackbarConfig(100, 1000, 100))
    trackbar_omega = StatefulTrackbar("omega", tb_range=TrackbarConfig(1, 50, init=50))
    trackbar_sigma = StatefulTrackbar("sigma", tb_range=TrackbarConfig(0, 3, 0.1))
    trackbar_phasem = StatefulTrackbar("phasem", tb_range=TrackbarConfig(0.1, 10, 0.1, init=0.1))

    # For any kind of 2D plot made available by this library, users may specify
    # a color map and the number of unique colors to use from that colormap. If
    # the number of colors specified is less than the number of curves /
    # featuers to be plotted, then modulo arithmetic is used to loop over the
    # available colors.
    #
    # NOTE: Check out PyQtGraph's examples which detail which colormaps are
    # available for a specific list of options with gradients displayed
    # alongside them. The available colormaps differ from other libraries and
    # only include extras like those from Matplotlib under certain
    # circumstances (which have yet to be tested).
    #
    # For line plots, users may also specify a line_width argument which sets
    # the width of any curve in pixels. The final option currently available is
    # fillLevel, which causes the area under any curve to be shaded between the
    # curve and this value. The default value is None which results in the area
    # under the curve not being shaded.
    pv_a = StatefulPlotView2D(
        callback=callback_line,
        config=PlotView2DConfig(
            auto_colors_cmap="plasma",
            auto_colors_nunique=3,
            title="Signal Aliasing: Labeled Line Graph",
            label_x="Sample Number",
            label_y="Amplitude",
            legend=True,
        ),
        title="Line Plot Version",
    )
    pv_b = StatefulPlotView2D(
        callback=callback_scatter,
        config=PlotView2DConfig(
            background_color="white",
            auto_colors_cmap="plasma",
            auto_colors_nunique=3,
            title="Signal Aliasing: Labeled Line Graph",
            label_x="Sample Number",
            label_y="Amplitude",
        ),
        title="Line Plot Version",
    )
    # Users can animate any display pane by wrapping the associated widget in
    # an `Animator`. Here, an fps value can be specified to limit the refresh
    # rate. Do note that the user specified callback must execute quickly
    # enough for the desired animation rate to be achievable. In addition, it
    # must provide a named parameter `animation_tick` which provides the
    # function the current tick value of the animation timer. This can be
    # paired up with modulo arithmetic (% operator) to loop over data sequences
    # or modify the output as "time" moves forward.
    animator = StatefulAnimator(ups=60, auto_start=False)

    # Scatter panes are another feature provided by the current version of the
    # library. Like line plots, color maps can be specified here as well. In
    # addition, the user has be option to specify the size of each point symbol
    # as well as the kind of symbol drawn.
    # For a full list of symbols, visit the documentation for PyQtGraph and
    # review their resouces for scatter plots.

    # IMPORTANT: Rendering multiple animations does not occur simultaneously,
    # at least not yet. Use caution if you are animating many windows at the
    # same time as the time to update each window will stack. Follow these
    # issues for updates on the features planned which solve this problem.
    # - https://github.com/seantronsen/pvt/issues/14
    # - https://github.com/seantronsen/pvt/issues/22
    context = VisualizerContext.create_viewer_from_mosaic(
        [
            [pv_a, pv_b],
            [animator],
            [trackbar_n, trackbar_omega],
            [trackbar_phasem, trackbar_sigma],
        ],
    )
    app.add_panes(context)
    app.run()


################################################################################
################################################################################
# OLD - UPDATE AWACHES IMPLEMENTATION OF CACHING ENGINE
################################################################################
################################################################################
#
# # An example of how to display static / unchanging content
# def demo_static_image_viewer():
#     img_test = cv2.imread("sample-media/checkboard_non_planar.png").astype(np.uint8)
#     img_test = norm_uint8(cv2.cvtColor(img_test, cv2.COLOR_BGR2GRAY))
#
#     image_viewer = Viewer()
#
#     # For the time being, specifying a "dummy" lambda is the best way to render
#     # static content. The downside being that if the pane is connected to the
#     # global state, the content is redrawn each and every time the state
#     # changes. While the cost is miniscule on the compute side, the same cannot
#     # be said for the rendering side where there is a real cost to repainting
#     # the window unnecessarily. Keep an eye on issue #43 for more information
#     # and changes related to improving the efficiency of static content. For
#     # now, take comfort by realizing the cost for images less than 8K
#     # resolution is still low enough that you shouldn't notice a difference
#     # (though you really should consider shrinking the images at that point
#     # just for faster processing in your own code).
#     #
#     # NOTE: Users can now specify a `border` keyword argument to automatically
#     # draw a border of the specified color around the image. This reduces the
#     # need to do it yourself and considering the scaling / width for arbitrary
#     # resolutions and is particularly useful for when the content being
#     # displayed has the same background color as the panel (which typically
#     # results in making it difficult to determine where the image begins and
#     # ends).
#     ip = ImagePane(lambda **_: img_test, border="red")
#     image_viewer.add_panes(ip)
#     image_viewer.run()
#


# For a simpler experience regarding choosing demos to run, pass the CLI call
# an additional argument with the name of the demo.
#
# Example: `python demo.py demo_image_viewer`
if __name__ == "__main__":
    if len(sys.argv) == 1:
        demo_plot_viewer()
        # demo_image_viewer()
    else:
        globals()[sys.argv[1]]()
