##################################################
# FILE: demo.py
# AUTHOR: SEAN TRONSEN
#
# SUMMARY:
# The contents of this file are written with the intent to illustrate basic
# usage of the package utilities. Users should not expect it to be
# comprehensive.
#
# Should the reader have any questions, they are advised to first skim through
# the source code and read the inline documentation. For any questions that
# still remain, please get in touch with the author or submit a github issue.
##################################################
##################################################

# NOTE: Performance logging can be enabled with this environment variable.
# IMPORTANT: It must be set via the command line or prior to importing the
# library
import os

os.environ["VIEWER_DEBUG"] = "1"  # remove to disable performance logging

from pvt.app import App
from pvt.context import VisualizerContext
from pvt.controls import StatefulAnimator, StatefulTrackbar
from pvt.displays import (
    PlotDataLine,
    PlotDataScatter,
    PlotView2DConfig,
    StatefulImageView,
    StatefulImageViewLightweight,
    StatefulPlotView2D,
)
from pvt.qtmods import TrackbarConfig
from pvt.decorators import use_parameter_cache


# STANDARD IMPORTS
import cv2
import numpy as np
import sys
from pvt.utils import norm_uint8, resize_by_ratio

# IMPORTANT: Visualizer Context & Callback Parameter Handling:
#
# The visualizer context is a grouping mechanism that links control widgets
# and data display widgets. Only controls and displays within the same
# context communicate, ensuring that state updates and data refreshes don't
# interfere across unrelated explorations.
#
# Callback Parameter Handling:
#
#   - Callbacks receive parameters as keyword arguments (key=value pairs) generated by
#     control widgets in the same visualizer context.
#
#   - Control widgets emit state updates where the key of the key=value pair must match the callback's
#     parameter name exactly for proper mapping.
#
#   - Use **kwargs in your callback to ignore extra parameters if your function only
#     needs a subset of the provided variables.
#
#   - Without **kwargs, the callback must explicitly define a parameter for every control
#     widget variable, or Python will raise an exception.
#
# This approach lets you focus on the parameters your callback truly requires while the
# context takes care of the rest.


def demo_image_viewer():
    img_test = cv2.imread("sample-media/checkboard_non_planar.png").astype(np.uint8)
    img_test = norm_uint8(cv2.cvtColor(img_test, cv2.COLOR_BGR2GRAY))

    # IMPORTANT: Expensive and avoidable computations should be completed prior for
    # best results. Slow rendering times can only be attributed to bottlenecks
    # in the callback functions you define. For more details, export
    # `VIEWER_DEBUG=1` to the list of environment variables.
    #
    # EXAMPLE: Compare rendering speed for interactions with the resize vs.
    # sigma sliders (resize performs more computation, making it slower by
    # comparison).
    img_test_small = img_test.copy()
    img_test = resize_by_ratio(img_test, 10)
    noise_image = np.random.randn(*(img_test.shape)).astype(np.int8)  # pyright: ignore

    # todo: we can probably remove the requirement for kwargs with a little
    # extra designing. of course that comes with a perf cost, but we can decide
    # on that later.
    def callback_a(rho, sigma, **_):
        resized = resize_by_ratio(img_test, rho)
        noise_slice = noise_image[: resized.shape[0], : resized.shape[1]]
        result = resized + (noise_slice * sigma)
        return result

    # the default config for this decorator is to whitelist all **named**
    # parameters. Regardless of the configuration options applied, it will
    # always exclude positional parameters (*args), and exclude keyword
    # parameters (**kwargs). Per the design of this library, only kwargs is
    # acceptable and it's only purpose in these callback functions is to house
    # arguments used by other arguments in the same context that this specific
    # callback function doesn't care for. In this example, `rho` will be in the
    # **kwargs dict since this function does not directly specify it as a named
    # parameter. remember in this library, kwargs is a way of ignoring
    # unnecessary arguments provided by the execution engine.
    #
    # based on the comments above, an equivalent decorator config would be
    # @use_parameter_cache(whitelist=["sigma"])
    @use_parameter_cache
    def callback_b(sigma, **_):
        noise_slice = noise_image[: img_test_small.shape[0], : img_test_small.shape[1]]
        result = img_test_small + (noise_slice * sigma)
        return result

    # define interface and run application
    # happy tuning / visualizing!
    app = App(title="Example for Displaying Rapid Image Updates")

    trackbar_rho = StatefulTrackbar(key="rho", config=TrackbarConfig(start=0.001, stop=1, step=0.001, init=0.5))
    trackbar_sigma = StatefulTrackbar("sigma", TrackbarConfig(0, 100, 2))
    ip_a = StatefulImageView(callback_a, title="resized image")
    ip_b = StatefulImageView(
        callback_b,
        config=ImageViewConfig(border_color="red", autoRange=False),
        title="small image for perf",
    )

    # IMPORTANT: add all display and control elements to a context so they can communicate
    # this helper function also creates a mosaic (grid-like) layout of the widgets
    context = VisualizerContext.create_viewer_from_mosaic([[ip_a, ip_b], [trackbar_rho, trackbar_sigma]])
    app.add_panes(context)
    app.run()


def demo_static_image_viewer():

    # EXAMPLE: callback optimizations can be applied with the decorator below.
    # In this example, we will explore "fake caching" where users can specify
    # which parameters should trigger a new frame to be computed, then rendered
    # on the data display.
    #
    # There are two options for tracking:
    # - inclusive tracking:
    # - exclusive tracking
    #
    # only one type can be selected for this kind of optimization.
    #
    # NOTE: this is most useful for if you have an animator in the same context
    # as several displays, but not all of the displays need to be updated on
    # each animation tick.
    #
    # IMPORTANT: ANY NAMED PARAMETERS **NOT** DEFINED BY YOUR CALLBACK FUNCTION
    # ARE NOT USED. Meaning, if you've created several display widgets and each
    # of which uses a different subset of parameters (named arguments), meaning
    # the extra args from the callback engine go into kwargs, that there is no
    # need to worry about anything in kwargs. the optimizations handle that for
    # you automatically.

    img_test = norm_uint8(cv2.imread("sample-media/checkboard_non_planar.png"))

    @use_parameter_cache(blacklist="all")
    def callback(**_):
        return img_test

    app = App(title="Example: Static Images")
    trackbar_sigma = StatefulTrackbar("sigma", TrackbarConfig(0, 100, 2))
    ip = StatefulImageView(callback, config=StatefulImageView.Config())

    # IMPORTANT: add all display and control elements to a context so they can communicate
    # this helper function also creates a mosaic (grid-like) layout of the widgets
    context = VisualizerContext.create_viewer_from_mosaic(
        [
            [ip],
            [trackbar_sigma],
        ],
    )
    app.add_panes(context)
    app.run()


def test_rgb_image_render_speed():

    img_test = norm_uint8(cv2.imread("sample-media/checkboard_non_planar.png", cv2.IMREAD_GRAYSCALE))
    img_test = cv2.applyColorMap(img_test, colormap=cv2.COLORMAP_MAGMA)
    img_test = cv2.GaussianBlur(img_test, ksize=(17, 17), sigmaX=9, sigmaY=9)
    img_test = resize_by_ratio(img_test, ratio=30)
    img_test = np.asarray(cv2.cvtColor(img_test, cv2.COLOR_BGR2RGB), dtype=np.uint8)

    def callback(**_):
        return img_test

    app = App(title="Test RGB Render Speed")
    animator = StatefulAnimator(ups=240, auto_start=True, show_ups_info=True)
    ip = StatefulImageViewLightweight(
        callback,
        config=StatefulImageViewLightweight.Config(border_color="red"),
    )

    context = VisualizerContext.create_viewer_from_mosaic([[ip], [animator]])
    app.add_panes(context)
    app.run()


# todo: need to add a demo showing how use_parameter_cache(blacklist="animation_tick")
# can be used to force a data display to ignore animation tick updates. this is
# useful when only one display requires an animation and the others should
# ignore it. though, I suppose we could also just use the default whitelist all
# for a function that doesn't name animation tick as a parameter.
#
# really starting to get into the land of hiding complexities away from the
# user. not sure if that's something I entirely want. while they may want to
# not know about the shared state, that invites them to assume many behaviors
# about the engine which may or may not be true.


# An example to showcase various plotting features
def demo_plot_viewer():
    N_WAVES = 5
    AUTO_COLORS = 4

    def _callback_base(nsamples, sigma, omega, phasem, animation_tick, **_):
        cphase = (animation_tick / (2 * np.pi)) * phasem
        sinusoid = np.sin((np.linspace(0, omega * 2 * np.pi, nsamples) + cphase))
        noise = np.random.randn(nsamples)
        result = sinusoid + (noise[:nsamples] * sigma)
        return np.array([result] * N_WAVES) + (np.arange(N_WAVES).reshape(-1, 1) - ((N_WAVES - 1) / 2))

    def callback_line(nsamples, sigma, omega, phasem, animation_tick, **_):
        result = _callback_base(nsamples, sigma, omega, phasem, animation_tick, **_)
        return [PlotDataLine(x=np.arange(signal.size), y=signal, name=f"item: {i}") for i, signal in enumerate(result)]

    def callback_scatter(nsamples, sigma, omega, phasem, animation_tick, **_):
        result = _callback_base(nsamples, sigma, omega, phasem, animation_tick, **_)
        return [PlotDataScatter(x=np.arange(signal.size), y=signal, marker="x") for signal in result]

    app = App(title="Multiple Plots: An Illustration of Signal Aliasing")

    trackbar_n = StatefulTrackbar("nsamples", config=TrackbarConfig(100, 1000, 100))
    trackbar_omega = StatefulTrackbar("omega", config=TrackbarConfig(1, 50, init=50))
    trackbar_sigma = StatefulTrackbar("sigma", config=TrackbarConfig(0, 3, 0.1))
    trackbar_phasem = StatefulTrackbar("phasem", config=TrackbarConfig(0.1, 10, 0.1, init=0.1))

    # For any kind of 2D plot made available by this library, users may specify
    # a color map and the number of unique colors to use from that colormap. If
    # the number of colors specified is less than the number of curves /
    # featuers to be plotted, then modulo arithmetic is used to loop over the
    # available colors.
    #
    # NOTE: Check out PyQtGraph's examples which detail which colormaps are
    # available for a specific list of options with gradients displayed
    # alongside them. The available colormaps differ from other libraries and
    # only include extras like those from Matplotlib under certain
    # circumstances (which have yet to be tested).
    #
    # For line plots, users may also specify a line_width argument which sets
    # the width of any curve in pixels. The final option currently available is
    # fillLevel, which causes the area under any curve to be shaded between the
    # curve and this value. The default value is None which results in the area
    # under the curve not being shaded.
    pv_a = StatefulPlotView2D(
        callback=callback_line,
        config=PlotView2DConfig(
            auto_colors_cmap="plasma",
            auto_colors_nunique=AUTO_COLORS,
            title="Signal Aliasing: Labeled Line Graph",
            label_x="Sample Number",
            label_y="Sample Height",
            legend=True,
        ),
        title="Line Plot Version",
    )
    pv_b = StatefulPlotView2D(
        callback=callback_scatter,
        config=PlotView2DConfig(background_color="white", title="Signal Aliasing: Labeled Scatter Graph"),
    )
    # Users can animate any display pane by wrapping the associated widget in
    # an `Animator`. Here, an fps value can be specified to limit the refresh
    # rate. Do note that the user specified callback must execute quickly
    # enough for the desired animation rate to be achievable. In addition, it
    # must provide a named parameter `animation_tick` which provides the
    # function the current tick value of the animation timer. This can be
    # paired up with modulo arithmetic (% operator) to loop over data sequences
    # or modify the output as "time" moves forward.
    animator = StatefulAnimator(ups=60, auto_start=True, show_ups_info=True)

    # Scatter panes are another feature provided by the current version of the
    # library. Like line plots, color maps can be specified here as well. In
    # addition, the user has be option to specify the size of each point symbol
    # as well as the kind of symbol drawn.
    # For a full list of symbols, visit the documentation for PyQtGraph and
    # review their resouces for scatter plots.

    # IMPORTANT: Rendering multiple animations does not occur simultaneously,
    # at least not yet. Use caution if you are animating many windows at the
    # same time as the time to update each window will stack. Follow these
    # issues for updates on the features planned which solve this problem.
    # - https://github.com/seantronsen/pvt/issues/14
    # - https://github.com/seantronsen/pvt/issues/22
    context = VisualizerContext.create_viewer_from_mosaic(
        [
            [pv_a, pv_b],
            [animator],
            [trackbar_n, trackbar_omega],
            [trackbar_phasem, trackbar_sigma],
        ],
    )
    app.add_panes(context)
    app.run()


# For a simpler experience regarding choosing demos to run, pass the CLI call
# an additional argument with the name of the demo.
#
# Example: `python demo.py demo_image_viewer`
if __name__ == "__main__":
    if len(sys.argv) == 1:
        # demo_image_viewer()
        # demo_static_image_viewer()
        demo_plot_viewer()
    else:
        globals()[sys.argv[1]]()
